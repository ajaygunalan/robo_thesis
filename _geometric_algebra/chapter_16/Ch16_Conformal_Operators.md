# 16 Conformal Operators

Even with all the new techniques for Euclidean geometry in the previous three chapters, the possibilities of the conformal model are not exhausted. There are more versors in it, and they represent other useful transformations. Euclidean motions were just a special case of doing *conformal transformations*, which preserve angles. These also include reflection in a sphere and uniform scaling.

All conformal transformations are generated by versor products using the elementary vectors of the conformal model. Whereas the Euclidean motions of the previous chapter involved using the vectors representing dual planes, we now use the dual spheres. An important operation we can then put into rotor form is *uniform scaling*, and that permits a closed-form solution to the interpolation of rigid body motions with scaling.

The fact that the general conformal transformations can be represented as versors finally explains the name of the conformal model.

---

## 16.1 Spherical Inversion

The most elementary conformal transformation is the reflection in a unit sphere, called (spherical) inversion. As a versor, the spherical inversion in the unit sphere $\Sigma$ around the origin involves the vector $\sigma = o - \infty/2$, representing this sphere dually. The spherical reflection is performed by the versor product:

$$X \mapsto \sigma \hat{X} \sigma^{-1}.$$

A unit sphere of weight 1 (so that $-\infty \cdot \sigma = 1$) is equal to its own inverse, simplifying the equation slightly. We compute the effect on the basic elements:

$$o \mapsto -(o - \tfrac{1}{2}\infty) \, o \, (o - \tfrac{1}{2}\infty) = -\tfrac{1}{4}\infty \, o \, \infty = \infty/2$$

$$\infty \mapsto -(o - \tfrac{1}{2}\infty) \, \infty \, (o - \tfrac{1}{2}\infty) = -o \, \infty \, o = 2o$$

$$\mathbf{E} \mapsto (o - \tfrac{1}{2}\infty) \, \hat{\mathbf{E}} \, (o - \tfrac{1}{2}\infty) = -\tfrac{1}{2} o \, \hat{\mathbf{E}} \, \infty + \tfrac{1}{2} \infty \, \hat{\mathbf{E}} \, o = -\mathbf{E}(o \cdot \infty) = \mathbf{E}.$$

It is clear that this is not a Euclidean transformation, for $\infty$ is not preserved but interchanged with $o$ (and weighted). Geometrically, this is understandable: the point at infinity reflects to the center of the sphere, and vice versa. The total result on a point $x = \mathsf{T}_{\mathbf{x}}[o]$ is

$$\mathsf{T}_{\mathbf{x}}[o] = o + \mathbf{x} + \tfrac{1}{2}\mathbf{x}^2\infty \;\mapsto\; \mathbf{x}^2 \left( o + \mathbf{x}^{-1} + \tfrac{1}{2}\mathbf{x}^{-2}\infty \right) = \mathbf{x}^2 \, \mathsf{T}_{\mathbf{x}^{-1}}[o].$$

Not only does the point $x$ end up at location $\mathbf{x}^{-1}$ (which is the inverse of $\mathbf{x}$, hence the name inversion), but its weight also changes by a factor $\mathbf{x}^2$. A real dual unit sphere gives a point in the same direction as $\mathbf{x}$; an imaginary dual unit sphere gives $\mathsf{T}_{\mathbf{x}}[o] \mapsto -\mathbf{x}^2\mathsf{T}_{-\mathbf{x}^{-1}}[o]$ (as you can derive in structural exercise 1). Therefore the latter performs an inversion, while simultaneously reflecting in the origin, which is somewhat surprising but pleasant to have available as a versor.

**Figure 16.1:** Inversion of various elements in a unit sphere (shaded in red) produces their reflection relative to that sphere. We show a point $p$ at location $\mathbf{p}$ relative to the sphere's origin (denoted in black) that becomes a point at location $1/\mathbf{p}$; an oriented line $\Lambda$ that becomes a circle through the center; a circle $K$ that becomes a circle; and a point pair $\Gamma$ that becomes a point pair. The black point at the center is the reflection of the point at infinity. Labels of the rounds are indicated at their centers. All containment and composition relationships are preserved, as are angles between the elements before and after reflection.

Figure 16.1 shows the inversion of various elements in a sphere. Containment relationships are of course preserved, but there is more. The spherical inversion is a *conformal transformation*: it preserves local angles. In the figure, the angle between the green line and blue circle is the same as between their images after reflection. This angle preservation property is best demonstrated by considering two tangents at the same location $p$, which are $p \wedge (p \rfloor (\mathbf{u}\,\infty))$ and $p \wedge (p \rfloor (\mathbf{v}\,\infty))$. Inverting the tangent $p \wedge (p \rfloor (\mathbf{u}\,\infty))$ using the equations above, we find it in a nonstandard form as

$$2\mathbf{p}^4 \, p' \wedge (p' \rfloor (\mathbf{u}\,o)),$$

where we used the notation $p'$ for the unit point at location $\mathbf{p}^{-1}$. Using the direction formula from Table 14.1 and some algebraic simplification, you can establish that the direction of this tangent equals $-\mathbf{p}\mathbf{u}\mathbf{p}\,\infty$. Therefore the inversion of the tangent can be written in standard form as

$$p' \wedge (p' \rfloor (-\mathbf{p}\mathbf{u}\mathbf{p}\,\infty)).$$

The other tangent transforms in a similar way. If we now study the ratio of their Euclidean direction vectors at their common location, that transforms from $\mathbf{v}/\mathbf{u}$ to $(-\mathbf{p}\mathbf{v}\mathbf{p})/(-\mathbf{p}\mathbf{u}\mathbf{p}) = \mathbf{p}(\mathbf{v}/\mathbf{u})\mathbf{p}^{-1}$. This is a simple reflection in the plane with normal $\mathbf{p}$. For the two vectors $\mathbf{u}$ and $\mathbf{v}$, it affects the attitude of their plane $\mathbf{u} \wedge \mathbf{v}$, but not the magnitude of their relative sine or cosine. So although being in a different plane, the angle between $\mathbf{u}$ and $\mathbf{v}$ is preserved. It follows that reflection in a plane is a conformal transformation, and so is reflection in a sphere.

In contrast to the Euclidean operators we treated so far, the inversion in the sphere does not preserve the class of the element it acts on: the consequence of essentially swapping $o$ and $\infty$ is that flats can become rounds and directions can become tangents at the origin. This is also clear from the characterization of the classes in Table 14.1, which worked by testing whether $\infty \rfloor X$ and/or $\infty \wedge X$ are zero: the nonpreservation of $\infty$ implies that such a condition holding for $X$ may not hold for the transformed $X$.

Spherical inversions have interesting applications, and a well-chosen inversion can often transform a geometrical problem into a much simpler problem. Many examples of this may be found in [46], though in a classical form using complex numbers in the plane. The conformal model allows a much more powerful treatment of this principle in $n$-dimensional base spaces.

---

## 16.2 Applications of Inversion

### 16.2.1 The Center of a Round

We have seen above how the point at infinity $\infty$ was reflected into (twice) the center $o$ of the unit sphere at the origin that we were considering. Due to the versor nature, this result is translation-covariant, so that *the center of an arbitrary sphere can be obtained by reflection of $\infty$ in it*. There are some constants involved to obtain the center in normalized form, and the resulting formula is

$$\text{center of sphere:} \quad c = -\tfrac{1}{2}\rho^2 \sigma \, \infty \, \sigma^{-1} = -\tfrac{1}{2} \frac{\sigma \, \infty \, \sigma}{(\infty \cdot \sigma)^2},$$

resulting in a normalized point. A general round can be factored into a sphere cut by planes through its center. Those subsequent reflections do not disturb the location of the center, so the general formula is as indicated in Table 14.1.

### 16.2.2 Reflection in Spheres and Circles

The straightforward application of spherical inversion is to compute the reflection in a sphere of arbitrary elements. We have used this above in Figure 16.1 for the reflection in a unit sphere around the origin. By now you should be confident that this may be extended to arbitrary spheres anywhere, because it is a versor product, and will therefore combine well with other versor products. We can move the unit sphere or the elements anywhere, in any orientation, and still $\sigma \hat{X}/\sigma$ will perform the reflection, as illustrated in Figure 16.2. The only thing we cannot show now is that we are also allowed to change the radius of the sphere in a structure-preserving manner, although this may be obvious geometrically. We leave that until after we have the rotor for that scaling (already in the next section), and that will permit the rotor representation of reflection in spheres of arbitrary radius.

**Figure 16.2:** An oriented Euclidean line $\Lambda$ is reflected in a sphere $\sigma$ by the versor product $\sigma \hat{\Lambda} \sigma^{-1}$ to become a circle through the center.

We can also compose the reflections, first reflecting in a plane $\pi$ and then in a sphere $\sigma$ cutting the plane orthogonally (so that $\pi \cdot \sigma = 0$). The total result is that we have used the versor $\pi \sigma$:

$$\text{reflection in a circle:} \quad X \mapsto (\pi \sigma) \hat{X} (\pi \sigma)^{-1}.$$

Since $\pi$ was chosen through the center of the sphere $\sigma$, the versor $\pi \sigma$ is the dual representation of the circle that is their meet (as in the factorization of Section 15.2.3). This versor construction therefore gives a sensible meaning to *reflection in a circle*. In its plane, this acts like spherical inversion, but it can also be extended to act outside that plane. We found it hard to draw a convincing picture of this; because of its essential 3-D nature, it is best studied live in an interactive visualization. Structural exercise 3 explores reflection in a point pair, which is interestingly different from spherical reflection, even in the plane.

---

## 16.3 Scaling

### 16.3.1 The Positive Scaling Rotor

In Section 13.2.2, we generated a translation from reflections in two parallel dual planes. The natural question now is: What can we generate from the reflections in two "parallel" spheres (i.e., concentric spheres $o - \tfrac{1}{2}\rho_1^2\,\infty$ and $o - \tfrac{1}{2}\rho_2^2\,\infty$)?

We obtain a composite versor that is the product of the two inversions, and simplify:

$$(o - \tfrac{1}{2}\rho_2^2\infty)(o - \tfrac{1}{2}\rho_1^2\infty) = (\rho_1^2 + \rho_2^2) - \tfrac{1}{2}(\rho_1^2 - \rho_2^2) \, o \wedge \infty.$$

One would expect only the ratio of the sizes of the spheres to matter. We rescale the versor through dividing by $2\rho_1\rho_2$, and conveniently define a characteristic parameter $\gamma$ through

$$\exp(\gamma/2) = \rho_2/\rho_1.$$

Now some algebraic manipulation gives a pleasant standard form,

$$S_\gamma = \cosh(\gamma/2) + \sinh(\gamma/2) \, o \wedge \infty = e^{\gamma \, o \wedge \infty/2},$$

where the rewriting of the resulting rotor as an exponential uses the results in Section 7.4 combined with $(o \wedge \infty)^2 = 1$.

You may guess what the effect of this rotor is, since you know that it is geometrically a double sphere inversion: it scales elements relative to the origin. We compute what happens to the basic components of our representation. For brevity define $O \equiv o \wedge \infty$ (it represents the unit flat point at the origin), and note that $O^2 = 1$, as well as $O \, o = -o = -o \, O$ and $O \, \infty = \infty = -\infty \, O$. With that, it is easy to derive that

$$S_\gamma[\infty] = \left(\cosh(\gamma/2) + \sinh(\gamma/2) \, O\right) \infty \left(\cosh(\gamma/2) - \sinh(\gamma/2) \, O\right)$$
$$= \left(\cosh(\gamma/2) + \sinh(\gamma/2) \, O\right)^2 \infty = e^\gamma \infty.$$

Using the commutation relationships, you should dare to abbreviate this derivation as

$$S_\gamma[\infty] = e^{\gamma O/2} \, \infty \, e^{-\gamma O/2} = e^{\gamma O} \, \infty = \left(\cosh(\gamma) + \sinh(\gamma) \, O\right) \infty = e^\gamma \infty. \tag{16.1}$$

(Verify all steps in detail, if you need to be convinced.) Similarly,

$$S_\gamma[o] = e^{\gamma O/2} \, o \, e^{-\gamma O/2} = e^{\gamma O} \, o = \left(\cosh(\gamma) - \sinh(\gamma) \, O\right) o = e^{-\gamma} o. \tag{16.2}$$

The bivector $O$ commutes with a purely Euclidean blade $\mathbf{x}$, so

$$S_\gamma[\mathbf{E}] = \mathbf{E}.$$

In total, we find for the transform of a general point $x = \mathsf{T}_{\mathbf{x}}[o]$

$$S_\gamma[x] = e^{-\gamma} \left( o + (e^\gamma \mathbf{x}) + \tfrac{1}{2}(e^\gamma \mathbf{x})^2 \infty \right) = e^{-\gamma} \mathsf{T}_{e^\gamma \mathbf{x}}[o]. \tag{16.3}$$

This clearly shows that the spatial aspects are scaled by $e^\gamma$ (as well as weighted by $e^{-\gamma}$). So this is indeed a spatial scaling. You should realize that it has been characterized by an exponential parameter; so to obtain a scaling by a factor of 2, you need to use $\gamma = \log(2)$.

Note that this transformation is almost a Euclidean transformation: it does not quite preserve the point at infinity (as a Euclidean transformation would), but it merely weights it (which is not too bad). In particular, the type of an element is preserved in scaling, since the conditions of Table 14.1 are not affected by a weight on $\infty$. So rounds remain rounds, and flats remain flats. No Euclidean transformation can affect the size of an object, but once it has been determined by a scaling, it is nicely preserved.

There is a slight paradox in this use of the scaling rotor. The distance between Euclidean point representatives was originally defined through a ratio of inner products by (13.2). If the distance between the points should increase, so should the value of that inner product ratio. But the inner product is an invariant of the orthogonal transformation produced by the scaling rotor (by definition of an orthogonal transformation). When you check, you find that this indeed holds, because the scaling changes $\infty$ to $e^\gamma \infty$ and (16.3) trades spatial scale for point weight.

However, if we use the distance definition relative to the *original* point at infinity $\infty$, we find that the Euclidean distance of the points has indeed increased by a factor of $e^\gamma$ after scaling by $S_\gamma$. Apparently, that is how we should use the definition of distance: always relative to the original point at infinity.

This interpretation afterwards of course does not affect the consistency of the conformal model computations. Having scaling available as a rotor means that all our constructions are automatically structurally preserved under a change of scale---we never need to check that they are. For instance, any construction made with a unit sphere using the products of our geometry can be simply rescaled to involve any sphere of any radius at any position without affecting its structure. This scaling does not even need to be done relative to the origin; by virtue of the structure preservation, a scaling around another location $\mathbf{t}$ is simply made by applying the translation rotor to the scaling rotor to obtain the translated scaling as $\mathsf{T}_\mathbf{t}[S_\gamma]$.

### 16.3.2 Reflection in the Origin: Negative Scaling

When one of the parallel two reflecting spheres is imaginary, their product is a versor that is capable of reflecting in the origin. The prototypical example of this is the product of two unit spheres, one real, one imaginary. This gives the element

$$(o - \infty/2)(o + \infty/2) = o \wedge \infty.$$

This is the flat point in the origin, which makes perfect sense: negative scaling is like reflection in the origin. Its action on a conformal point is

$$\mathsf{T}_{\mathbf{x}}[o] \mapsto -\mathsf{T}_{-\mathbf{x}}[o].$$

Even though this is an even versor, it is not a rotor, for $(o \wedge \infty)(o \wedge \infty)^\sim = -1$. Therefore it cannot be performed in small amounts, and it cannot be expressed as the exponential of a bivector. It is a transformation, but not a motion.

You can combine this reflection in the origin with a scaling versor to effectively make a versor that can perform a negative scaling.

### 16.3.3 Positively Scaled Rigid Body Motions

The combination of a translation $T$, a rotation $R$, and a positive scaling $S$ (all with arbitrary center) can always be brought in the standard form $TRS$. This is most easily shown by considering swapping the rotors pairwise, as follows:

- The swapping law for translation and rotation is
  $$T_\mathbf{t} R = R \, T_{R^{-1}\mathbf{t}R}$$
  as we saw in (13.12).

- Rotation and scaling in the origin commute,
  $$R_{\mathbf{I}\phi} S_\gamma = S_\gamma R_{\mathbf{I}\phi},$$
  since their generating bivectors do.

- Scaling and translation do not commute, but satisfy
  $$T_\mathbf{t} S_\gamma = S_\gamma T_{e^{-\gamma}\mathbf{t}}.$$
  You can derive this algebraically or confirm it by the simple sketch of Figure 16.4.

**Figure 16.3:** A positively scaled rigid body motion rotor repeatedly applied to a circle and a point (both displayed in light colors) generates an escargoid (snail shell).

**Figure 16.4:** Swapping the order of a scaling rotor and a translation rotor implies that the translation needs to be rescaled.

Because of these commutation properties, we can always convert any sequence of rotors $S$, $R$, and $T$ into the standard order $TRS$, with suitable adaptation of the rotor parameters.

These rotors generate a logarithmic spiral; in 3-D. This can be used to generate a snail shell from a well-chosen circle, as in Figure 16.3. Note that this direct application to the 3-blade of the circle implicitly uses the structure preservation of the rotor, and is therefore typical of the conformal model. In the figure, we have also applied the same rotor to a small sphere to give a better impression of the 3-D nature of the shell.

### 16.3.4 Logarithm of a Scaled Rigid Body Motion

Refining the step size in the generation of transformations like Figure 16.3 should be done through interpolation of the rotor, completely analogous to the interpolation of rigid body motions in Section 13.6 and of rotations in Section 10.3.4. Correspondingly, we need a logarithm for this type of rotor to enable the computation of the required $V^{1/N}$ to perform the rotor $V$ in $N$ steps, as $\exp(\log(V)/N)$.

To determine the logarithm of the positively scaled rigid body motion $V = TRS$, we collate some partial results first.

- We have already determined the logarithm of the rigid body motion part $TR$, in (13.15).

- Scaling and rotation commute, so the logarithm of a rotor of the form $RS$ is easy to determine:
  $$\log(R_{\mathbf{I}\phi} S_\gamma) = \log(R_{\mathbf{I}\phi}) + \log(S_\gamma) = -\mathbf{I}\phi/2 + \gamma \, o \wedge \infty/2,$$
  the sum of the logarithms of the commuting rotors.

- The really new combination is that of a rotor of the type $TS$. This can be determined to be
  $$\log(T_\mathbf{t} S_\gamma) = \log(T_{\mathbf{t}\gamma/(e^\gamma - 1)}) + \log(S_\gamma) = -\frac{\gamma}{e^\gamma - 1} \mathbf{t}\infty/2 + \gamma \, o \wedge \infty/2, \tag{16.4}$$
  as you can verify by exponentiation and convenient grouping of terms into power series. If $\gamma = 0$, the fractional coefficient should take its limit value 1.

For the general positively scaled rigid body motion rotor in the form $V = TRS$, we decompose the rotor into known elements by applying the earlier factorization in the log for a rigid body motion of Section 12.5.3. We split off the part perpendicular to the plane of $R$, to write $V = T_\mathbf{w}(T_\mathbf{v} R_{\mathbf{I}\phi} T_{-\mathbf{v}}) S_\gamma$. The translation over $\mathbf{w} = (\mathbf{t} \wedge \mathbf{I})/\mathbf{I}$ is not affected by the rotation and therefore interacts with the scaling as (16.4). The other part should be described as the translation of a rotor of the type $RS$, so we need to look for its center, as the location $\mathbf{c}$ satisfying

$$R_{\mathbf{I}\phi}[e^\gamma \mathbf{c} - \mathbf{v}] + \mathbf{v} = \mathbf{c},$$

which solves to $\mathbf{c} = (1 - R^2 e^\gamma)^{-1}(1 - R^2)\mathbf{v} = (1 - R^2 e^\gamma)^{-1}(\mathbf{t} \rfloor \mathbf{I})/\mathbf{I}$ (where we used (13.13)). Relative to this center, the motion $V$ is in standardized form $RS$, and its logarithm can be taken. That then needs to be translated to the correct in-plane location and composed with the remaining $\mathbf{w}$ component. Combining all these ingredients produces the rather intimidating

$$\log(T_\mathbf{t} R_{\mathbf{I}\phi} S_\gamma) = \frac{\gamma}{1 - e^\gamma}((\mathbf{t} \wedge \mathbf{I})/\mathbf{I})\infty/2 + T_{(1-e^\gamma R^2)^{-1}(\mathbf{t} \rfloor \mathbf{I})/\mathbf{I}}[-\mathbf{I}\phi/2 + \gamma \, o \wedge \infty/2].$$

To apply this formula, you need to retrieve the parameters occurring in it from the total rotor $V$. This is done by observing that $-o \rfloor (V\infty) = -o \rfloor (R \, e^{\gamma O/2} \infty) = R \, e^{\gamma/2}$. Employing the additional demand on the normalization of the rotor $R\tilde{R} = 1$, we find $R$ and $\gamma$. Dividing out these rotors from $V$ gives the rotor $T$. The parameters of $R$ and $T$ are computed as in Section 7.4.4. As we did there, if $R = 1$, you can set $\mathbf{I} = 1$ and $\phi = 0$. If $\gamma = 0$ (so that $S = 1$), the fractional coefficient of $(\mathbf{t} \wedge \mathbf{I})/\mathbf{I}$ should take its limit value for small $\gamma$, which is $-1$ (this is automatic if you rewrite it in terms of a sinch function). The resulting function is indicated in Figure 16.5. The exceptions for $R$ are similar to the earlier rigid body motion logarithm of Figure 13.5.

**Figure 16.5: Computation of the logarithm of a positively scaled rigid body motion rotor $V$.**

```
log(V){
    X = -o⌋(V∞)
    γ = log(X X̃)
    if (γ == 0) then (no scaling)
        γ' = 1
    else
        γ' = γ/(e^γ - 1)
    endif
    S = e^(γ o∧∞/2)
    R = X e^(-γ/2)
    T = V S̃ R̃
    t = -2 o⌋T
    if (⟨R⟩₀ == -1) return ("no unique logarithm")
    if (⟨R⟩₀ == 1) (no rotation, so no I)
        log = -γ' t ∞/2 + γ o ∧ ∞/2
    else
        I = ⟨R⟩₂/‖⟨R⟩₂‖
        φ = -2 atan2(‖⟨R⟩₂‖, ⟨R⟩₀)
        Tᵥ = 1 - (1 - e^γ R²)⁻¹ (t⌋I)/I ∞/2
        log = -γ' (t ∧ I)/I ∞/2 + Tᵥ (-Iφ/2 + γ o ∧ ∞/2) T̃ᵥ
    endif
}
```

One may improve subsequent numerics by making sure to return a bivector through taking the grade-2 part $\langle \log \rangle_2$.

Having the logarithm gives us the tool we need to interpolate these motions in the usual manner, and it was used to generate the stepwise transformation of the elements in Figure 16.3.

The versor of a *negatively* scaled rigid body motion is not a rotor. It cannot be written in exponential form and does not have a logarithm. Since you cannot do such a motion piecewise anyway, you should not want to interpolate it.

---

## 16.4 Transversions

In the classical literature on conformal operations, one introduces the operation of *transversion*. This may be defined as the triple composition of an inversion in the unit sphere, followed by a translation, followed by another inversion in the unit sphere. It is easy to compute its rotor, which simplifies nicely:

$$(o - \infty/2)(1 - \mathbf{t}\infty/2)(o - \infty/2) = 1 + o\,\mathbf{t} = e^{o\mathbf{t}}.$$

The two inversions make it a handedness-preserving operation, a proper conformal transformation represented by an even versor, which is even a rotor. You might prefer to use the analogy with the introduction of a Euclidean rotation as the reflection in two planes with a common line, and define the transversion as the reflection in two spheres with a common point (use structural exercise 5 to show that this is essentially the same as the definition above).

From its form, the transversion clearly completes our types of primitive rotors in the conformal model using the last remaining factor of the bivector basis for its exponent (after $-\mathbf{t} \wedge \infty/2$ for translations, $\gamma \, o \wedge \infty/2$ for scaling, and a Euclidean $-\mathbf{I}\phi/2$ for rotations). The full list is in Table 16.1.

### Table 16.1: Basic operations in the conformal model and their versors

The improper transformations have vector versors, and change handedness. The reflection in the origin is an even versor, but not a rotor, and it has no exponential form. The proper conformal transformations are composed from even unit versors and can be written as the exponentials of bivectors. The table shows that all elements in the bivector basis are associated with a specifically named operation.

| Type of Operation | Explicit Form | Exponential Form |
|-------------------|---------------|------------------|
| reflection in origin plane | $\mathbf{n}$ | none |
| reflection in real unit sphere | $c - \infty/2$ | none |
| reflection in origin | $o \wedge \infty$ | none |
| rotation over $\phi$ in $\mathbf{I}$-plane | $\cos(\phi/2) - \sin(\phi/2)\,\mathbf{I}$ | $e^{-\mathbf{I}\phi/2}$ |
| translation over $\mathbf{t}$ | $1 - \mathbf{t}\infty/2$ | $e^{-\mathbf{t} \wedge \infty/2}$ |
| scaling by $e^\gamma$ | $\cosh(\gamma/2) + \sinh(\gamma/2)\,o \wedge \infty$ | $e^{\gamma \, o \wedge \infty/2}$ |
| transversion over $\mathbf{t}$ | $1 + o\,\mathbf{t}$ | $e^{o \wedge \mathbf{t}}$ |

A closed-form solution to the logarithm of a general conformal transformation also involving a transversion is not yet known.

---

## 16.5 Transformations of the Standard Blades

It is convenient to have a table with the most used transformations in standard form applied to the elements in standard form. This is Table 16.2.

### Table 16.2: Common proper transformations of some of the standard elements of the conformal model

The entry marked "Involved" is just the product of the transversions of $\infty$ and $\mathbf{E}$.

| Element | Translation $e^{-\mathbf{t}\infty/2}$ | Rotation $R$ | Scaling $e^{\gamma \, o \wedge \infty/2}$ | Transversion $e^{o\mathbf{t}/2}$ |
|---------|--------------------------------------|--------------|------------------------------------------|----------------------------------|
| $o$ | $t = o + \mathbf{t} + \tfrac{1}{2}\mathbf{t}^2\infty$ | $o$ | $e^{-\gamma}o$ | $o$ |
| $\infty$ | $\infty$ | $\infty$ | $e^\gamma \infty$ | $t' \equiv \infty + 2\mathbf{t} + 2\mathbf{t}^2 o$ |
| $\mathbf{E}$ | $-(\mathbf{E}\infty) \rfloor t$ | $R\mathbf{E}\tilde{R}$ | $\mathbf{E}$ | $\mathbf{E} + o(2\mathbf{t} \rfloor \mathbf{E})$ |
| $\mathbf{E}\infty$ | $\mathbf{E}\infty$ | $(R\mathbf{E}\tilde{R})\infty$ | $e^\gamma \mathbf{E}\infty$ | Involved |
| $o \wedge \mathbf{E} \wedge \infty$ | $(o + \mathbf{t}) \wedge \mathbf{E} \wedge \infty$ | $o \wedge (R\mathbf{E}\tilde{R}) \wedge \infty$ | $o \wedge \mathbf{E} \wedge \infty$ | $o \wedge \mathbf{E} \wedge (\infty + 2\mathbf{t})$ |
| $o - \infty/2$ | $t - \infty/2$ | $o - \infty/2$ | $e^{-\gamma}(o - e^{2\gamma}\infty/2)$ | $o - t'/2$ |

Contemplating this table, it is striking how the same versor operation leads to very different explicit forms for the various elements. In actual computations, it is of course often simpler to compute with the versors as long as possible, converting to explicit form only at the end---if at all. This applies both to computations done by hand and by using a computer. The use of versor products keeps the software clear and reduces errors. Only in very time-critical applications would you write things out---and even then, geometric algebra is useful since it provides the code generator with the automatically correct way of transforming arbitrary elements.

---

## 16.6 General Conformal Transformations

With the reflections and the complete suite of rotors, we can make any conformal transformation. The usefulness of these still needs to be explored, for although they are familiar in mathematics, they are rather new to computer science. In the framework of geometric algebra, they can of course be applied to any element, and that leads to interesting operations.

### 16.6.1 Loxodromes

Figure 16.6(a) shows what we get when applying the rotor

$$L \equiv e^{o \wedge \mathbf{e}_1 - \mathbf{e}_2 \wedge \infty} \tag{16.5}$$

to a circle multiple times. (We actually applied $L^{1/N}$ to show its action piecewise.) This is a *loxodromic transformation*, known from the study of the conformal group in two dimensions. As the figure suggests, it has two special points, a source and a sink, and it scales, translates, and rotates elegantly between them.

**Figure 16.6:** Loxodromes generated by applying the rotor $\exp((o \wedge \mathbf{e}_1 - \mathbf{e}_2 \wedge \infty)/10)$ multiple times to a circle: (a) in the $\mathbf{e}_1 \wedge \mathbf{e}_2$-plane, (b) in 3-D space.

The geometric algebra characterization of this transformation extends the classical treatment in two ways: it makes the transformation easily applicable to arbitrary basic elements such as flats and rounds (and the circle example gives a lot more insight in the structure of the mapping than merely transforming a point would have done). Also, there is no reason to limit the space to two dimensions; the same rotor works to transform $n$-dimensional space. The strange 3-D wormlike figures that result are best appreciated by an interactive software package such as GAViewer [18]; Figure 16.6(b) shows a rendering.

A rich class of shapes can be generated in this manner. Their simple expressibility means that they are easily refined, which is what one would wish from graphics primitives, so they may be useful to solid modeling. But this remains to be explored.

### 16.6.2 Circular Rotations

More immediately useful are *circular rotations*, which have rotation orbits not around a line (as in Figure 15.5) but around a circle $K$. Such a circular rotation is of the form $\exp(K^*)$. Each element $p \wedge K^* = (p \rfloor K)^*$ is a circle, curving around the circle $K$, as in Figure 16.7. You can use this to your advantage to compactly generate a torus given its two generator curves (a dual line and a dual circle). You may explore this in structural exercise 7, which generates the torus in Figure 16.12.

**Figure 16.7:** The circular orbits of a circle $K$, of the form $p \wedge K^*$.

The mere fact that circles can be used as basic descriptors to rule objects can already save a lot of memory and computation to manipulate them. This also remains to be explored.

### 16.6.3 Mobius Transformations

The usual way to study conformal transformations in mathematics is by means of Mobius transformations, so we mention that briefly. This technique, developed for 2-D, represents a vector as a complex number $z$ and a conformal transformation as the mapping

$$z \mapsto \frac{az + b}{cz + d}.$$

By choosing the complex numbers $a$, $b$, $c$, and $d$ appropriately, one can generate inversions, translations, rotations, and the other conformal transformations.

Since ratios are important, it makes sense to introduce complex homogeneous coordinates in the complex plane. Then the Mobius transformations admit a matrix representation: multiplication of the transformations is the same as multiplying the complex-valued matrices

$$\begin{bmatrix} a & b \\ c & d \end{bmatrix}.$$

For instance, the conjugated inversion in the unit circle at the origin is represented by the matrix $\begin{bmatrix} 0 & 1 \\ 1 & 0 \end{bmatrix}$, and a translation over $\mathbf{t}$ by $\begin{bmatrix} 1 & t \\ 0 & 1 \end{bmatrix}$ (where $t$ is the complex number corresponding to $\mathbf{t}$). Such representations allow one to compute products of conformal transformations easily.

All this is very clever, but also very limited. The matrix description of conformal transformations is very much point-based and, because of its use of complex numbers, tied to 2-D space. No such restrictions are felt when treating conformal transformations using the rotors of the conformal model. As we have seen before when discussing rotations and quaternions, there is no need to go to complex numbers to get an algebra that properly encodes the geometry.

---

## 16.7 Non-Euclidean Geometries

The conformal model can also be used for the description of other geometries. Hyperbolic and elliptic geometry find a natural home. We briefly mention the connection; more may be found in [15].

### 16.7.1 Hyperbolic Geometry

In Euclidean geometry, we kept the null vector $\infty$ invariant, because we wanted it to represent the point at infinity. We can model *hyperbolic geometry* in the conformal model by keeping the vector $e = o - \infty/2$ invariant instead. This is the (dual) unit sphere, and we obtain in this manner the Poincare disk model of hyperbolic geometry. Or rather, a Poincare hyperball, for the conformal model is not limited to 2-D. By letting the spherical border play the role of infinity, the whole metric of the space must adapt in precisely the right manner.

We briefly indicate the parallel with Euclidean geometry, for convenience of terminology and depiction taking the 2-D case as in Figure 16.8. We are used to our lines of $\mathbb{E}^2$ in direct representation to be represented as 3-blades with a factor $\infty$; in 2-D hyperbolic geometry, the corresponding special elements must contain a factor $e$. As a consequence, they do not plunge into the point at infinity $\infty$, but into the unit sphere $e$. In the Poincare depiction, they look like circles, as depicted in Figure 16.8.

Translations took place along Euclidean straight lines; in hyperbolic geometry, they must go along the hyperbolic lines. The translation along the line $L$ in Euclidean space is by a rotor with exponent $-\infty \rfloor L/2$; in hyperbolic space, this becomes the rotor $\exp(-e \rfloor L/2)$.

**Figure 16.8:** 2-D hyperbolic geometry in the conformal model. By considering the real dual unit circle $e = o - \infty/2$ as infinity, the hyperbolic lines become circles in the plane that meet the unit circle perpendicularly. (One such line is indicated as the green circle.) Translations are defined as moving elements along spherical lines. We show translated points at equal increments of hyperbolic distance, and the corresponding hyperbolic circles. This gives an impression of the hyperbolic metric on the Poincare disk. A flat point in the hyperbolic plane consists of a point and its (unreachable) reflected twin outside the disk, indicated in blue.

That has a strange consequence. Because of the null nature of the translation bivector in the Euclidean case, distance was clearly additive in the usual Euclidean sense. In the hyperbolic case, additivity of the translation bivector generates a metric that looks rather distorted on the Poincare disk. In Figure 16.8 we have indicated circles with the same center and increasing radii. Near the circle at infinity $e$, distances apparently become very large, and the points inside cannot escape the disk.

Hyperbolic motions can be made with versors that preserve $e$, and these can be generated by vectors of the form $\mathbf{n} + \delta e$. The conformal representation for this geometry can then run completely parallel to how we handled Euclidean geometry in Chapter 13.

### 16.7.2 Spherical Geometry

By taking the imaginary unit sphere $\bar{e} \equiv o + \infty/2$ as the preserved vector of all transformations, we get a model of *spherical geometry*. This is actually the geometry on an $n$-dimensional sphere, in which the role of the flats is played by the great circles.

We consider this model again in 2-D, for convenience in terminology and depiction (see Figure 16.9). The flats are now blades that contain $\bar{e}$. These are all circles that cut the unit circle in a point pair centered around the origin (i.e., in two diametrically opposite points). They are the images of the great circles on a sphere under stereographic projection from the south pole onto the plane of the equator. Such a projection is conformal, for it is the inversion in a sphere of radius $\sqrt{2}$ with its center at the south pole. That is how the conformal model contains a faithful representation of the geometry of the sphere into the plane. A flat point $p \wedge \bar{e}$ is a point pair (representing diametrically opposite points on the sphere).

**Figure 16.9:** 2-D spherical geometry in the conformal model. By considering the unit dual imaginary circle $\bar{e} = o + \infty/2$ as infinity, the spherical lines become circles in the plane that meet the unit circle in two opposite points. (A spherical line through two red points is indicated as the green circle.) Translations are defined as moving elements along spherical lines. We show the translation of a black circle by equal increments of spherical distance.
Also shown is the spherical image of this planar geometry (by a 3-D inversion in the real dual sphere $\mathsf{T}_{\mathbf{e}_3}[o] - \infty$, which is not depicted). In that spherical image, the spherical lines are great circles, and the translation is a slide along such a great circle. A flat point of the plane becomes a pair of diametrically opposite points on the spherical image.

The conformal translations are now effectively rotations on the sphere, and the corresponding distance measure is the angle between two great circles. The versors are generated by subsequent reflections in vectors of the form $\mathbf{n} + \delta e$, and represent the expected sliding over the spherical space.

By the same principle, you can now make arbitrary conformal versors act on elements residing on a sphere. It is very satisfying that we do not need to write special software to deal with this geometry (or hyperbolic geometry): its elements and operators are all part of the conformal model, which we originally implemented to do Euclidean geometry.

---

## 16.8 Further Reading

The use of the conformal model to actually do conformal geometry is still very recent. The original successful attempt to use rotors for their representation may have been [2], but this reference is highly mathematical.

The richly illustrated book by Needham [46] helps develop your geometrical intuition on conformal mappings. Even though it is mostly restricted to the complex plane and the algebraic language of Mobius transformations, he works hard at getting the geometry up front. You can now reproduce most illustrations in his book through the conformal model in GAViewer.

Our usual sources [33, 15] have additional material on the rotor method of representing conformal transformations. They explicitly spell out the relationship of the conformal model with stereographic projection.

A good source for the other geometries within the conformal model is the work of A. Lasenby, starting with the treatment in [15], which derives explicit expressions for the distances along the lines of the geometries.

---

## 16.9 Exercises

### 16.9.1 Drills

1. Reflect the line $L$ through locations $\mathbf{e}_1$ and $\mathbf{e}_2$ in the unit sphere at the origin.

2. Factorize the result of the previous exercise to determine its center and squared radius.

3. Reflect the tangent vector at $\mathbf{e}_1 + \mathbf{e}_2$ in the direction $2\mathbf{e}_3$ in the unit sphere at the origin. Notice especially the weight of the result!

4. Scale the line $L$ by a factor of $e^2$ from the origin.

5. Scale the line $L$ by a factor of $e^2$ from the point $\mathbf{e}_1$.

6. Reflect the line $L$ in the origin.

7. Reflect the line $L$ in the point $\mathbf{e}_1$.

### 16.9.2 Structural Exercises

1. Show that the general inversion formula for a point in a dual sphere at the origin $o - \tfrac{1}{2}\rho^2\infty$ is
   $$\mathsf{T}_{\mathbf{x}}[o] \mapsto \frac{\mathbf{x}^2}{\rho^2} \mathsf{T}_{\rho^2 \mathbf{x}^{-1}}[o].$$
   Note that this implies that imaginary spheres involve a central reflection in the origin (as well as the inversion of the distances to the origin).

2. Now that we have conformal model and spherical inversion, we can look at the pinhole camera with different eyes (see Figure 16.10). In that figure, an eyeball is defined by its pinhole $o$ and the focal point $f$ on the optical axis. A point $x$ images on the eyeball as $x_e$. In the pinhole box camera of Figure 12.2, this point would have been imaged as $x_p$. Show that the two are related by inversion in the indicated sphere $f \rfloor (o \wedge \infty)$, which also transforms the eyeball as whole into the blue imaging plane.

3. Figure 16.11 shows the reflection of various elements in the brown point pair; all elements reside in the plane of the drawing. Compare this to the spherical reflection Figure 16.1 and understand the differences. (Hint: Use the factorization of the point pair by a sphere and well-chosen planes.)

4. Prove that flats through the origin are invariant under scaling.

5. We claimed in Section 16.4 that a transversion can also be constructed as the reflection in two touching spheres. To determine the standard form of such a transversion, put the spheres symmetrically around the origin, with their centers at $\pm\mathbf{a}$. Show that this gives the transversion versor as $-\mathbf{a}^2(1 - 2o \wedge \mathbf{a}^{-1})$. What should you take as the distance of the touching spheres to obtain the standard transversion rotor $\exp(o \wedge \mathbf{t})$?

6. Show that the loxodromic rotor of (16.5) can be written as the commuting product of two more elementary rotors:
   $$e^{(o-\infty)(\mathbf{e}_1 - \mathbf{e}_2)/2} \, e^{(o+\infty)(\mathbf{e}_1 + \mathbf{e}_2)/2}.$$
   Analyze what these do using software.

7. In Figure 16.12, we have generated a torus by generating a few circles. The inversion in a sphere of a torus is called *Dupin's cycloid*. In the conformal model, its circles are simply the torus circles, inverted in the sphere. Write pseudocode to generate this figure with just a few parameterized operations.

8. The invariance of a vector $a$ under the versors places the demand $a = -\hat{V} a V^{-1}$ on the versor, which implies that $a \rfloor V = 0$. If the versor $V$ is a rotor, it can be written as the exponent of a bivector. Show that any bivector of the form $a \rfloor T$ with $T$ an arbitrary trivector leaves $a$ invariant. Relate this to the translations of the various geometries we discussed (i.e., what trivector should you choose to get a translation?).

9. Figure 16.13 depicts the same situation, at the same scale, of a green line $L = p \wedge q \wedge i$ through two points $p$ and $q$ (one of which is the center of the black circles), and a flat point $r \wedge i$ (in blue). In all three figures, the line is used in a translation versor $\exp(i \rfloor L/2)$ to translate the point $p$ over equal distances, and dual circles are made with the original point as its center as $t \rfloor (p \wedge i)$. The only difference is the element used for the infinity $i$ (in light red). Identify the metrics and explain the differences as quantitatively as you can. You can pick $i$ from $\mathbf{e}_1$, $o$, $\infty$, $o - \infty/2$, $o + \infty/2$, or $o + \mathbf{e}_2 + \infty/2$.

---

## 16.10 Programming Examples and Exercises

### 16.10.1 Homogeneous $4 \times 4$ Matrices to Conformal Versors

This example draws the same GLUT models that we have used in many other examples before. The user can translate, rotate, and scale the model. The example intends to demonstrate how to convert $4 \times 4$ homogeneous matrices (e.g., from OpenGL) to conformal versors: We construct a particular transformation on the OpenGL modelview matrix stack, read out the matrix, and convert this to a versor. Then we reset the modelview matrix to the identity and use the versor to apply the transformation.

The full matrix-to-versor conversion function is called `matrix4x4ToVersor()` and resides in `c3ga_util.cpp`. Due to limitations on the transformations that the conformal model can represent, there are certain restrictions on the type of matrices we can handle. The matrix should only contain translation, rotation, and uniform scaling (i.e., the same along all axes). Such a matrix has the form

$$\begin{bmatrix} s_1 s_2 [\![R]\!] & s_2 [\![\mathbf{t}]\!] \\ \mathbf{0}^T & s_2 \end{bmatrix},$$

where $[\![R]\!]$ is a $3 \times 3$ rotation matrix, $[\![\mathbf{t}]\!]$ is a $3 \times 1$ translation vector, and $s_1$ and $s_2$ are scalars. $s_1$ is the actual scaling, while $s_2$ is just a homogeneous scaling factor that can in principle be removed without side effects (i.e., it does not affect our interpretation of transformed objects, only their weight).

The first step is to get rid of the $s_2$ factor by normalizing the matrix. Optionally, the matrix is transposed (OpenGL represents its matrices in column-major order, while we use row-major order). Once normalized, the translation part of the matrix is easily extracted as vector $\mathbf{t}$.

To separate the rotation from the scale, we initialize three vectors that are the images of the basis vectors `imageOfE1`, `imageOfE2`, and `imageOfE3`. In principle, the overall scale is the norm of any of these three vectors. However, to increase precision slightly we set scale to the average of the norm all three vectors.

Once $s_1$ is found, we can normalize the rotation matrix and convert it to a rotor $R$ using the existing `matrixToRotor()` function from Section 7.10.3. There is one problem, however; the scaling may be negative. In Section 16.3.2, we have described this as the application of an extra versor $o \wedge \infty$. The algorithm needs to detect and handle this, for the (Euclidean) norm of a vector is always positive, hence so is $s_1$. Negative scaling can be detected by computing the determinant of the rotation matrix.

**Comparison: Conformal Versors vs. $4 \times 4$ Homogeneous Coordinate Matrices**

- **Storage.** Storage is similar; to (densely) store a translation-rotation-scaling (TRS) versor, 12 floats are required, while the corresponding $4 \times 4$ matrix requires 13 floats.

- **Speed.** Application of a versor to a vector is about 30 percent slower than applying a $4 \times 4$ matrix to a vector. And because $4 \times 4$ matrices are so commonly used, mainstream CPUs have special hardware that can efficiently apply $4 \times 4$ matrix transformations. Hardware specialized for geometric algebra is not yet mainstream.

- **Universality.** Transforming blades that are not versors is straightforward with versors, since the same method is used to transform any blade or versor. The $4 \times 4$ matrices can be applied directly only to vectors. In practice, one uses outermorphisms to transform the higher-grade blades. These can be generated easily with the versors, but need to be hand-coded in the matrix approach.

- **Inverses.** Computing the inverse of a versor $V$ is trivial ($V^{-1} = \tilde{V}/(V\tilde{V})$). Inverting a $4 \times 4$ matrix is harder, even when you use the tricks that speed up inversion of TRS transformations.

- **Interpolation.** Interpolation is more natural for versors, since for many rotors we have a logarithm in closed form. Logarithms of matrices are notoriously expensive to compute (although there are some special closed form solutions known here, too).

- **Conversion.** Versors can be converted to $4 \times 4$ matrices trivially (the columns of the matrix are the images of the four basis blades $\mathbf{e}_1 \wedge \infty$, $\mathbf{e}_2 \wedge \infty$, $\mathbf{e}_3 \wedge \infty$ and $o \wedge \infty$ under the versor). From matrix to versor is more involved.

- **Geometries.** The $4 \times 4$ matrices can also be used to do nonuniform scaling (and thus skewing) and (perspective) projection of vectors. The versors in the conformal model cannot, though other geometric algebras may be developed in which the versors have such actions. On the other hand, conformal versors can also represent inversions in a sphere and other conformal transformations that enable them to be used directly for spherical geometry.

### 16.10.2 Logarithm of Scaled Rigid Body Motion

The code for computing the logarithm of a `TRSversor` (translate-rotate-scale-versor) is a straightforward implementation of the pseudocode in Figure 16.5 in Section 16.3.4. The function resides in `c3ga_util.cpp`. Note that the function returns the `TRSversorLog` type, which is a specialized multivector type (the basis blades are $\mathbf{e}_1 \wedge \mathbf{e}_2$, $\mathbf{e}_1 \wedge \mathbf{e}_3$, $\mathbf{e}_2 \wedge \mathbf{e}_3$, $\mathbf{e}_1 \wedge n_i$, $\mathbf{e}_2 \wedge n_i$, $\mathbf{e}_3 \wedge n_i$, and $n_o \wedge n_i$). The example itself just tests the `log()` code by repeatedly generating random TRS versors $V$ and checking that $V = \exp(\log(V))$.

### 16.10.3 Interpolation of Scaled Rigid Body Motions

We now revisit the interpolation examples from Sections 10.7.1 and 13.10.4, this time adding the scalability. We interpolate from one random TRS versor to the next.

Using the `log()` function from the previous example, the interpolation code requires little change compared to previous version:

```cpp
TRSversor interpolateTRSversor(const TRSversor &src, const TRSversor &dst, mv::Float alpha) {
    return _TRSversor(src * exp(_TRSversor(alpha * log(_TRSversor(inverse(src) * dst)))));
}
```

### 16.10.4 The Seashell

This example code reproduces Figure 16.3. You can drag the outermost circle and sphere around to produce variations of the figure. The code to draw the shell is:

```cpp
// Create versor that generates the sea shell:
TRSversor V = _TRSversor((1.0f - 0.25f * e3ni) *
    exp(_bivectorE3GA((e1^e2) * 0.4f)) *
    exp(_noni_t(-0.05f * noni)));

// Take 1/5th of the versor:
V = exp(0.2f * log(V));

// precompute inverse of the versor:
TRSversor Vi = _TRSversor(inverse(V));

// get the circle:
circle C = g_circle;

// draw the circles:
const int NB_ITER = 200;
for (int i = 0; i < NB_ITER; i++) {
    draw(C);
    // update circle such that we draw a 'trail' of circles
    C = V * C * Vi;
}

// get the sphere:
sphere S = g_sphere;

// draw spheres:
for (int i = 0; i < NB_ITER; i++) {
    draw(S);
    // update sphere such that we draw a 'trail' of spheres
    S = V * S * Vi;
}
```

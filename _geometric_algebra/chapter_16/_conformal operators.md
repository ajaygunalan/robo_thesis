# Conformal Operators

Euclidean motors were the warm-up: they're the conformal model behaving nicely because they leave the point at infinity $\infty$ alone. Chapter 16 is where the model starts acting like what its name promised—**conformal**, not merely Euclidean—by leaning into the fact that *versors built from the model's elementary vectors generate the whole conformal group*. The pivot is that you stop treating dual planes as the only "reflection primitives" and start using **dual spheres** as first-class operators.

The door opens with [[spherical inversion and reflections]]. A single spherical inversion already breaks the Euclidean spell: $\infty$ is no longer invariant, so flats and rounds can swap roles, directions can turn into tangents, and "what kind of object" something is becomes transformation-dependent. Yet this apparent chaos is disciplined: inversion is conformal, so local angles survive even as global shape classes morph. Once you accept inversion as primitive, it becomes a Swiss-army knife: it can *extract latent Euclidean data* (like the center of a round) and can be composed into reflections that don't even have a clean Euclidean analog (like reflection in a circle acting meaningfully off its plane).

Then [[scaling rotor]] lands as the next big consolidation: scaling is not a hacky "multiply coordinates" add-on, but a versor born from **two concentric inversions**. That matters less for "we can scale things" (you always could) than for what it buys structurally: scale becomes a transformation that composes cleanly with the rest of the algebra, so entire constructions can be rescaled without re-deriving anything.

Once scaling is a versor, it immediately infects motion. [[scaled rigid body motions and interpolation]] shows that translation, rotation, and positive uniform scaling form a coherent TRS ecosystem inside conformal GA: you can reorder them systematically (with parameter updates), you can apply them repeatedly to generate logarithmic spirals in 3-D (the seashell), and—crucially—you can *interpolate* them because a closed-form logarithm exists for the TRS case. This is the practical moment where "CGA is elegant" turns into "CGA gives me a closed-form stepping operator."

But the conformal model still had one bivector "direction" left unused by the usual Euclidean trio. [[transversion]] fills that gap with an operation that classical conformal geometry treats as fundamental: an inversion–translation–inversion sandwich that becomes a proper rotor. With it, the primitive rotor vocabulary of the conformal model feels complete: you can now name a canonical transformation associated with each bivector flavor the model naturally offers.

With primitives in hand, [[general conformal transformations]] is the chapter's "what does this enable?" gallery: loxodromes and circular rotations show that conformal versors produce families of curves and ruled shapes that are awkward to express in purely Euclidean terms, and the discussion of Möbius transforms reframes a familiar 2-D complex-number story as a special case of a far more uniform n-D rotor calculus. There's also a hard edge: beyond TRS, a general closed-form logarithm (notably when transversions enter arbitrarily) isn't available here, so interpolation has a boundary.

Finally, [[non-euclidean geometries in the conformal model]] reveals a deeper unification: Euclidean geometry is just the choice to preserve $\infty$. If instead you preserve a *sphere-like* vector, the very same algebra becomes a computational home for hyperbolic or spherical geometry—no new representational machinery, just a different "infinity." In that sense, conformal GA isn't merely a tool for Euclidean space with extras; it's a chassis for multiple conformal geometries, selected by what you decide must remain fixed.

# The Homogeneous Model

The homogeneous model is an unapologetically "one extra dimension" hack with a serious payoff: you get to compute with *offset* geometry (points, lines, planes, general flats not through the origin) as if it were origin-based linear algebra, without splitting your code into "this is a point so translate it" versus "this is a vector so don't." The price is that you must stop thinking of your computational space as "the real space" and accept an embedding layer whose only job is to make the algebra close cleanly.

Once you buy the embedding, everything starts with the representation of location as something that behaves linearly under the algebra of the bigger space, so that points carry a built-in weight and directions become "points at infinity" in the same data type; that shift is the conceptual engine of the chapter, and it lives in [[embedding and points in the homogeneous model]]. From there, the outer product stops being a mere subspace span operator and becomes a universal constructor for *oriented flats with offsets*: a line is a single bivector element, a plane is a trivector, and in general a $k$-flat in the base space is a $(k+1)$-blade in the representation space—one object that you can reshape algebraically into direction/moment/support forms depending on what you need, as developed in [[flats as blades lines planes k-flats]].

But the model doesn't just want you to build objects—it wants you to *compute relationships* without branching on special cases. That's why the chapter insists on having both direct and dual forms: direct blades are tested by wedging with points, dual blades are tested by contraction, and moving between them is systematic duality in the representation space. That "two views of the same flat" viewpoint is what makes incidence computations feel like a closed calculus rather than a zoo of ad hoc formulas, and it's the heart of [[dual flats and hyperplanes]].

With that machinery in place, meet and join become the natural language for intersection and span, and the *reason* homogeneous coordinates were historically loved—parallel things intersect "at infinity," so cases unify—drops out as algebraic closure. Even better, the meet doesn't just return *where* things meet; it returns a *weighted* result whose magnitude often signals numerical stability and whose sign encodes orientation. That entire computational philosophy—do one algebraic thing, interpret later—crystallizes in [[incidence meet join and projective invariants]], where you also see the chapter's invariants story: affine distance ratios survive affine maps, cross ratios survive full projective maps.

All of this would be far less compelling if you still had to hand-roll how motions act on every object type. The homogeneous model's other big win is that translations become linear operators on the same multivector types you already use for flats, rotations remain rotor sandwiches, and affine/projective transformations appear as honest linear maps of the embedding space with clean outermorphism extensions to blades. That's the operational payoff captured in [[motions translation rotation affine projective]].

And then the chapter pulls the rug: the representation space has a metric you're free to choose for computational convenience, which is the tell that metric products in that space are not "Euclidean geometry in disguise." If you lean on dot products, inverses, or versor constructions in the embedding space as if they were physically meaningful, you will compute perfectly valid things—in the wrong geometry. The cleanup is not a patch; it's a model upgrade (the conformal model later). The diagnosis and a couple of surprisingly non-metric reinterpretations (like "projection as a meet construction") are the point of [[metric pitfalls of the homogeneous model]].

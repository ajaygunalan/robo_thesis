The homogeneous model isn't trying to be a universal "do-everything" Euclidean engine. It's at its best when your problem is mostly about *incidence*—which points/lines/planes meet, span, coincide, or miss—and only secondarily about metric facts. Chapter 12 cashes that out in two arenas that are notoriously messy in coordinate-only thinking: treating **3D lines as first-class computational objects** and treating **multi-camera imaging** as a clean projective geometry problem.

The first half starts by making one move feel inevitable: if points are homogeneous vectors, then lines should be what you get by wedging two points. Once you accept that, "Plücker coordinates" stop being a weird 6-number trick and become the coordinate face of a bivector. That viewpoint is laid out in [[plucker line coordinates from the outer product]] and it immediately removes the cultural damage done by traditional Plücker tables: you don't memorize a zoo of ad-hoc formulas—you regenerate them from standard products. The other ingredient that makes this coherent (and prevents you from mixing apples and grenades) is keeping straight what lives in which grade/basis, especially for planes whose duals can masquerade as point-vectors if you're sloppy; that bookkeeping is the real point of [[homogeneous points and planes]].

Once those embeddings are in place, the "magic" table entries become boring: a plane through a line and a point is just a wedge; a point/plane "coincidence" spits out an oriented distance as a scalar; skew lines return a signed separation by a meet. The punchline isn't the individual formulas—it's the pattern that *the algebra is doing the bookkeeping for you*, and it will happily produce the variants that aren't in anyone's table. That theme is what [[meet join and distance recipes]] is really about.

Then the chapter pivots from "formulas" to "code": if your transformations are linear maps on the homogeneous representation space, they induce outermorphisms on blades—so points, lines, and planes all transform by consistent, grade-appropriate matrices. You get the familiar $4\times 4$ point matrix, but you also get the right $6\times 6$ line matrix (and its dual-line counterpart) without inventing new rules. The computational win is that you never need a dense $16\times 16$ multivector matrix: the useful pieces are sparse and grade-separated. That whole bridge from geometry to efficient implementation lives in [[affine matrices in plucker space]].

The second half shows why this same toolkit is almost unfairly well matched to imaging geometry. A pinhole camera is "just" a pinhole point and an image plane; projection is meeting the ray with that plane. The key trick is that although the Euclidean map looks nonlinear, the homogeneous/blade-level map is linear *and* an outermorphism—so spans (joins) project nicely. That story is [[pinhole projection as a meet]].

Finally, once "an observation" is expressed as a blade object (a ray line for a point observation, a ray *plane* for a line observation), multi-view constraints become one-line incidence statements: "these rays must intersect" or "these ray-planes must meet in a line." Dualize when you want the scalar/matrix form, and you recover the epipolar constraint/essential matrix, then push to three cameras and you're staring at the trifocal tensor. The chapter even goes all the way to an applied reconstruction loop (motion capture markers) built out of epipolar lines and closest-point-on-rays primitives. That whole multi-camera arc lives in [[epipolar and trifocal constraints]].

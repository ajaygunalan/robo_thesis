# Rotor Sandwiching

A rotor is what you get when you stop treating "rotation" as a matrix and start treating it as "two reflections glued together." The reward is a uniform action on every grade, and a representation that carries more geometry (including orientation/sense) than a rotation matrix typically exposes.

## Rotations are double reflections

Take two reflections in vectors $a$ and $b$ lying in the same plane. Reflecting $x$ first in $a$, then in $b$, produces a rotation in the plane $a \wedge b$. Algebraically the two sandwiches fuse:

$$
x \mapsto b \, (a \, x \, a^{-1}) \, b^{-1} = (b a^{-1}) \, x \, (b a^{-1})^{-1}.
$$

So the rotation is generated by

$$
R = b a^{-1}.
$$

If $a, b$ are unit vectors, $a^{-1} = a$ and $R = ba$. Normalizing once is the practical move because for a **unit rotor**

$$
R^{-1} = \widetilde{R},
$$

the reverse, so the rotation is applied as

$$
X \mapsto R \, X \, \widetilde{R}
$$

for *any* multivector $X$ (vectors, bivectors, blades, mixed grades—same operator form).

## The half-angle form and the "bivector angle"

For unit $a, b$, their geometric product splits:

$$
R = ba = b \cdot a + b \wedge a.
$$

Write $\phi$ for the rotation angle, and $I$ for the unit bivector of the rotation plane (the normalized $a \wedge b$). Then

$$
R = \cos(\phi/2) - I \sin(\phi/2).
$$

Everything is encoded in the bivector "angle" $I \phi$: the scalar part carries $\cos(\phi/2)$, while the bivector part carries both the plane and $\sin(\phi/2)$.

## What the sandwich actually does to a vector

The rotor formula looks too small to contain a full 3-D rotation—until you decompose $x$ relative to the rotation plane.

Let $I$ be the unit plane bivector with $I^2 = -1$ (Euclidean case). Split

* $x_{\perp}$: component perpendicular to the plane (rejection),
* $x_{\parallel}$: component inside the plane (projection),

and define the in-plane quarter-turn $x_{\parallel}^\perp = x_{\parallel} I$.

The key commutation facts are geometric: $x_{\perp}$ commutes with $I$, while $x_{\parallel}$ anticommutes with $I$. Those two relations alone drive the sandwich computation to the expected rotation:

$$
R \, x \, \widetilde{R} = x_{\perp} + \cos\phi \, x_{\parallel} + \sin\phi \, x_{\parallel}^\perp.
$$

No basis construction is required; the "right" local frame $\{x_{\perp}, x_{\parallel}, x_{\parallel}^\perp\}$ is implicit in the algebra.

This also explains the efficiency claim: rotation matrices carry sines and cosines in duplicated slots; rotors carry them once, and composition stays purely multiplicative.

## Sense, $\pm R$, and why $4\pi$ shows up

Applying a rotor uses $R \, x \, \widetilde{R}$, so $R$ and $-R$ produce the same result on an isolated object. But the sign is not meaningless: it distinguishes **oriented rotations** when you care about continuity/relative motion of connected systems (the "plate trick" intuition).

Algebraically, negating a rotor shifts the effective half-angle by $\pi$, i.e., it changes the representative in a way consistent with a $4\pi$ periodic covering. The scalar part's sign tells you whether the represented rotation is the "short" one (effective angle $\le \pi$), and the bivector part's sign relative to $I$ tells you the rotation direction (with $I$ defining what "positive" means).

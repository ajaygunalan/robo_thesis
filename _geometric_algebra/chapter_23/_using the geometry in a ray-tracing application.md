# _using the geometry in a ray-tracing application

This chapter is basically a stress test: take the conformal model of Euclidean geometry (CGA), and see how far "write geometry as geometry" can be pushed before performance forces you back into ad-hoc representations. The result isn't a purity contest; it's an engineering story about keeping the *specification* clean while letting the *storage* get pragmatic when it has to.

The backbone is a classical ray tracer, but the chapter's real point is that you can treat a scene as a collection of geometric primitives and transformations, then execute the same expressions you'd write on a whiteboard. The "what are we even building?" and the pragmatic constraints (polygon meshes only, OpenGL-like shading, recursion for reflection/refraction, plus the reality of runtime costs) live in [[cga ray tracer overview]]. That note sets the tone: CGA is not slow by default, but you only get speed if you choose representations that match your hot loops.

Once you commit to polygonal scenes, your "world" becomes a pile of vertices, faces, planes, and edge lines—objects that CGA represents naturally, but that still need to be stored in a way that won't punish interpolation and repeated queries. The chapter's mesh choices are a small manifesto: keep positions as normalized conformal points because they behave well under spanning and interpolation, store surface attitude in the algebraically appropriate grade, and don't be afraid to reject a more "unified" blade if extracting what you need is too expensive. That entire representational ecosystem is in [[mesh primitives for polygonal scenes]].

Then the chapter pivots to something that's easy to underestimate: interactive modeling. Here CGA stops being "a nicer way to write intersection math" and becomes a direct map from mouse motion to transformations. You're not assembling 4×4 matrices full of coordinates; you're exponentiating the right bivector or translator and composing versors in the right order. This is where elegance and performance mostly align: the formulas are short and the intent is obvious. The concrete "mouse → versor → object/camera" pipeline is in [[scene transformations and interactive modeling]].

With a scene you can move around, rays become the main currency. And this is where the chapter's central compromise shows up: the most philosophically satisfying ray representation (one blade per object) is not the one you want in a tracer. You pick a representation that makes spawning, transforming, and intersecting cheap—even if it splits "a ray" across two blades. The trade study and the final choice sit in [[ray representation and spawning]].

After that, the narrative tightens around runtime: intersection dominates, so you need to spend your cleverness on acceleration and on picking intermediate representations that don't trigger expensive decompositions over and over. The chapter's intersection story is really about *dataflow*: clip to a coarse bound, descend a partition hierarchy, and only then touch triangles. The CGA angle is that each step is still expressed as meet/join-style operations on geometric objects, but with representations chosen to avoid needless algebra. That's in [[acceleration structures and ray-model intersection]].

Finally, geometry becomes appearance. Shading itself is mostly classical (ambient/diffuse/specular), but the chapter shows exactly where CGA still matters: you already have attitudes, directions, and transformations as geometric objects, so reflection/refraction become direct algebraic operations, and shadow visibility becomes a clean geometric query. The rendering loop becomes "trace → shade → possibly spawn → recurse" without losing semantic clarity. The optical side of that loop is in [[reflection refraction and shading]].
